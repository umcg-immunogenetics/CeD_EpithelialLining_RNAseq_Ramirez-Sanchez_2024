#Script generated by: Aaron D. Ramirez-Sanchez 
#Goal: To plot correlations crypt ratio versus some genes

##ENVIRONMENT
library(DESeq2)
library(biomaRt)
library(Hmisc)
library(ggplot2)
library(cowplot)

##FUNCTIONS
theme.plain <- function(p, base_size = 11, base_family = "ArialMT") {
  p <- p + theme_linedraw(base_size = base_size, base_family = base_family) %+replace%
    theme(panel.background = element_blank(),
          #panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(color="black", size=0.75),
          axis.ticks = element_line(size=0.75),
          axis.text = element_text(size=base_size, family="ArialMT", face="plain"),
          strip.background = element_blank(),
          strip.text = element_text(size=base_size, family="ArialMT", face="plain"),
          legend.key = element_blank(),
          legend.text = element_text(size=base_size, family = "ArialMT", face="plain"),
          complete = TRUE,
          plot.title = element_text(hjust=0.5))
  return(p)
}
plot_gene_cor <- function(symbol.gene){
  gene <- symbol.gene
  index <- which(symbols == c(gene))
  ensembl <- DEG.list[index]
  data.p <- data.frame(gene = as.data.frame(mat_scaled[ensembl,]), 
                       "Crypt_ratio" = as.numeric(annotation.data$crypt_ratio),
                       "Condition" = annotation.data$condition)
  names(data.p) <- c("Gene","Crypt_ratio", "Condition")
  
  p <- ggplot(data.p, aes(x = Crypt_ratio, y = Gene, color = Condition)) +
    geom_point(alpha = 0.6)+
    geom_smooth(method=lm, color = "black") +
    ggtitle(paste("r = ", round(rvalues["x",ensembl], 4),
                  "; p-val = ", formatC(pvalues["x",ensembl], format = "e", digits = 2))) +
    theme_classic() +
    xlab("Crypt ratio (APOA4/MKI67)") + ylab(paste(gene, " expression")) +
    #xlab("Crypt ratio (APOA4/MKI67)") + ylab(paste("Normalized and centered expression",gene)) +
    theme(plot.title = element_text(hjust = T, size=10)) + scale_color_manual(values=c("#2A2B2DFF","#2DA8D8FF","#D9514EFF")) +
    theme(legend.position = "none")
  return(p)
}

##INPUT
#read object DEseq and metadata
#DE <- read.csv("DEG.significative_stricter_pval_l2fc_cluster.csv", sep=',')
#Loading RNA matrix
RNA.DEG <- as.matrix(read.csv(file = "./output/tables/gene_expression/RNA_matrix_zeroVar.table", sep="\t", row.names = 1))

#Loading metadata
annotation.data <- read.delim(file = "./data/processed/metadata/extended_metadata.tsv", sep = "\t", row.names = 1)
annotation.data$marsh.2 <- as.factor(annotation.data$marsh.2)

#Loading merged DEG 
DEG.merged <- read.csv(file = "./output/tables/DEG/extended_comparisons_merged.csv", header = T, stringsAsFactors = F)

#Filters used for the DEG
L2FC.filter <- 1.0
p.adj.filter <- 0.01

#Filtering data
DEG.merged <- DEG.merged[(abs(DEG.merged$log2FoldChange) > L2FC.filter & !is.na(DEG.merged$log2FoldChange)) & 
                           (DEG.merged$padj < p.adj.filter & !is.na(DEG.merged$padj)), ]
DEG.list <- unique(DEG.merged$ENSEMBL)

RNA.DEG <- RNA.DEG[match(DEG.list, rownames(RNA.DEG)),]

#Scaling matrix. 2 options, first scaled and second vst
base_mean <-  rowMeans(RNA.DEG)
mat_scaled <-  t(scale(t(RNA.DEG)))
#mat_scaled <- RNA.DEG
#creating dds object, only including condition in model (there may be a warning, which you may ignore)
#dds <- DESeqDataSetFromMatrix(countData = RNA.DEG,
#                              colData = annotation.data,
#                              design= ~ condition)
#vst <- assay(vst(dds, blind=FALSE))

##MAIN

#correlations
#cor(as.numeric(annotation.data$marsh.2), as.numeric(annotation.data$crypt_ratio))
#cor.test(as.numeric(annotation.data$marsh.2), as.numeric(annotation.data$crypt_ratio))
#rcorr(as.numeric(annotation.data$marsh.2), as.numeric(annotation.data$crypt_ratio))


cor.m <- rcorr(y=t(RNA.DEG), x=as.numeric(annotation.data$crypt_ratio))
pvalues <- cor.m$P
pvalues <- as.data.frame(pvalues)

rvalues <- cor.m$r
rvalues <- as.data.frame(rvalues)

#hist(pvalues$x, breaks = 100)
#hist(rvalues$x, breaks = 100)


DEG.df <- as.data.frame(t(RNA.DEG))
#DEG.df
#apply(DEG.df, MARGIN = 1, as.numeric)
#cor.test(as.numeric(annotation.data$crypt_ratio), RNA.DEG)

m.cor <- lapply(y = as.numeric(annotation.data$crypt_ratio), X = DEG.df, FUN = cor.test)




symbols <- DEG.merged[match(DEG.list, DEG.merged$ENSEMBL),]$SYMBOL



#plot_gene_cor()
plots <- lapply(symbols[!is.na(symbols)], plot_gene_cor)

#pdf(file = "output/plots/Correlations_DEG.pdf", width = 4, height = 4)
#plots
#dev.off()

pdf(file = "output/plots/Correlations_DEGv2.pdf", width = 6, height = 6)
plot_grid(theme.plain(plot_gene_cor("MCM10")) + theme(legend.position = "none"),
          theme.plain(plot_gene_cor("IFNG")) + theme(legend.position = "none"),
          theme.plain(plot_gene_cor("MS4A10")) + theme(legend.position = "none"),
          theme.plain(plot_gene_cor("COL25A1")) + theme(legend.position = "none"))
dev.off()


write.table(data.p, file= "metaData_cryptRatios_131022.txt", sep='\t', eol='\n', col.names = T, row.names = F)



#This is not necessary
cor.m$r[ensembl,"y"]
cor.m$p[ensembl,"y"]
#IRIS

bulk <- read.csv("eQTLs_uniqueGene_lowestPval_FDR_reducedCols.tsv", sep='\t')
imm <- read.csv("Immune_unique_eQTLs_lowest_pval_fdrV2.tsv", sep='\t')
epi <- read.csv("Epithelial_unique_eQTLs_lowest_pval_fdrV2.tsv", sep='\t')


epi_sig <- epi[epi$Epithelial_cells_pvalue < 0.05,]
imm_sig <- imm[imm$Immune_Cells_pvalue < 0.05,]

# Overlap DE with eQTLs
bulk_DE <- merge(DE, bulk, by="ENSEMBL", all=F)
imm_DE <- merge(DE, imm_sig, by="ENSEMBL", all=F)
epi_DE <- merge(DE,epi_sig, by="ENSEMBL", all=F)

# load the countTable and metaData
countTable <- read.table("/Users/irishelenejonkers/Documents/UMCG/projects/epithelial layer eQTL project/data/BackUp_epithelialOslo_data2.expression.genelevel.v75.htseq.txt", header=TRUE)
# to continue with the table, we need to create rownames of the column named "probes" in which the gene_IDs are located
rownames(countTable) <- countTable$probe
countTable <- countTable[,-1]
head(countTable)
metaData <- read.csv("/Users/irishelenejonkers/Documents/UMCG/projects/epithelial layer eQTL project/data/metaData_BackUp_BMS_2022.csv", sep=',')

# normalize
countTable <- countTable[,as.character(metaData$sample)]

#creating dds object, only including condition in model (there may be a warning, which you may ignore)
dds <- DESeqDataSetFromMatrix(countData = countTable,
                              colData = metaData,
                              design= ~ condition)
vst <- assay(vst(dds, blind=FALSE))

##### Make plot to corrleate IL18 and Marsh (IL18 = ENSG00000150782)
ensembl  <- useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl", GRCh=37)
genemap <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol"),
                 filters = "ensembl_gene_id",
                 values = rownames(vst),
                 mart = ensembl )
vst.2 <- merge(x = vst, y = genemap, by.x = 0, by.y = "ensembl_gene_id", all.x = TRUE, all.y = FALSE)
head(vst.2)
#Select genes
il18 <- vst.2[vst.2$hgnc_symbol == "IL18"| vst.2$hgnc_symbol == "IL18RAP" | vst.2$hgnc_symbol ==  "IL18R1",]
il18 <- t(il18)
colnames(il18) <- il18[84,]
il18 <- il18[-1,]
il18 <- merge(il18, metaData, by.x=0, by.y="sample")
#Plot+correlation
plot(il18$marsh.2, il18$IL18, pch=16, xlab = "marsh score", ylab = "IL18 expression (vst)")
abline(lm(il18$IL18 ~ il18$marsh.2),col=4, lwd=3)
coef <- round(coef(lm(il18$IL18 ~ il18$marsh.2)), 2)
text(2,10.5,paste("r = -0.67; p-val=3.8e-12"))
cor(il18$marsh.2, as.numeric(il18$IL18), method = "pearson")
cor.test(il18$marsh.2, as.numeric(il18$IL18), method = "pearson")

####### Calculate the APOA4/MKI67 ratio to correlate to the MARSH scores and gene expression
ratio <- vst.2[vst.2$hgnc_symbol == "MKI67"| vst.2$hgnc_symbol == "APOA4",]  
ratio <- t(ratio)
colnames(ratio) <- ratio[84,]
ratio <- ratio[-1,]
ratio <- ratio[-83,]
ratio <- data.frame(ratio)
ratio$crypt_ratio <- as.numeric(ratio$APOA4)/as.numeric(ratio$MKI67)

metaData_ratio <- merge(metaData, ratio, by.x="sample", by.y=0)

plot(metaData_ratio$marsh.2, metaData_ratio$crypt_ratio, pch=16, xlab = "marsh score", ylab = "crypt ratio (APOA4/MKI67)")
abline(lm(metaData_ratio$crypt_ratio ~ metaData_ratio$marsh.2),col=4, lwd=3)
coef <- round(coef(lm(metaData_ratio$crypt_ratio ~ metaData_ratio$marsh.2)), 2)
text(2,1.8,paste("r = -0.77; p-value < 2.2e-16"))
cor(metaData_ratio$marsh.2, as.numeric(metaData_ratio$crypt_ratio), method = "pearson")
cor.test(metaData_ratio$marsh.2, as.numeric(metaData_ratio$crypt_ratio), method = "pearson")

write.table(metaData_ratio, file= "metaData_cryptRatios_131022.txt", sep='\t', eol='\n', col.names = T, row.names = F)

### Use crypt ratio to make correlations with gene expresssion of interesting genes.
metaSmall <- data.frame(cbind(metaData_ratio$sample, metaData_ratio$marsh.2, metaData_ratio$crypt_ratio))
colnames(metaSmall) <- c("sample", "marsh", "ratio")
vst.DE <- vst.2[vst.2$Row.names %in% DE$ENSEMBL,]
vst.tDE <- t(vst.DE)

colnames(vst.tDE) <- vst.tDE[1,]
vst.tDE <- vst.tDE[-1,]
vst.tDE <- merge(vst.tDE, metaSmall, by.x=0, by.y="sample")
row.names(vst.tDE) <- vst.tDE$Row.names
vst.tDE <- vst.tDE[,-1]

# correlations with ratio:
correlations_ratio <- data.frame(ncol=3, nrow=ncol(vst.tDE))
for (i in 1:ncol(vst.tDE)){
  correlations_ratio[i,1] <- colnames(vst.tDE)[i]
  tmp <- cor.test(as.numeric(vst.tDE$ratio), as.numeric(vst.tDE[,i]), method = "pearson")
  correlations_ratio[i,2] <- cor.test(as.numeric(vst.tDE$ratio), as.numeric(vst.tDE[,i]), method = "pearson")[4]
  correlations_ratio[i,3] <- cor.test(as.numeric(vst.tDE$ratio), as.numeric(vst.tDE[,i]), method = "pearson")[3]
}
correlations_ratio$corrected_pval <- correlations_ratio$p.value*1099
colnames(correlations_ratio) <- c("ENSEMBL", "r_ratio", "p.value_ratio", "p.value_cor_ratio")

# correlations with marsh:
correlations_marsh <- data.frame(ncol=3, nrow=ncol(vst.tDE))
for (i in 1:ncol(vst.tDE)){
  correlations_marsh[i,1] <- colnames(vst.tDE)[i]
  tmp <- cor.test(as.numeric(vst.tDE$marsh), as.numeric(vst.tDE[,i]), method = "pearson")
  correlations_marsh[i,2] <- cor.test(as.numeric(vst.tDE$marsh), as.numeric(vst.tDE[,i]), method = "pearson")[4]
  correlations_marsh[i,3] <- cor.test(as.numeric(vst.tDE$marsh), as.numeric(vst.tDE[,i]), method = "pearson")[3]
}
correlations_marsh$corrected_pval <- correlations_marsh$p.value*1099
colnames(correlations_marsh) <- c("ENSEMBL", "r_marsh", "p.value_marsh", "p.value_FDR_marsh")

# Combine
correlations <- merge(correlations_marsh, correlations_ratio, by="ENSEMBL")
correlations_DE <- merge(DE, correlations, by="ENSEMBL", all.x=T, all.y=F)

write.table(correlations, file="Pearson_corr_CryptRatio_Marsh_DEs_13102022.txt", sep='\t', eol='\n', row.names = F, col.names = T)


ggplot(cluster_genes, aes(x=crypt_ratio, y=as.numeric(cluster_genes[,i]))) +
  geom_point(alpha = 0.6)+
  geom_smooth(method=lm) +
  ggtitle(paste("r = ",round(correlations_DE$r_ratio[correlations_DE$SYMBOL==i & !is.na(correlations_DE$SYMBOL)],2),
                 "; p-val = ", signif(correlations_DE$p.value_FDR_ratio[correlations_DE$SYMBOL==i & !is.na(correlations_DE$SYMBOL)],2))) +
  theme_classic() +
  xlab("crypt ratio (APOA4/MKI67)") + ylab(paste("expression",i, "(vst)")) +
  theme(plot.title = element_text(hjust = T, size=10))

##OUTPUT