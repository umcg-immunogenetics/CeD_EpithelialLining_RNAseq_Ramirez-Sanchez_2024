#Script generated by: Aaron D. Ramirez-Sanchez 
#Goal: To plot correlations crypt ratio versus some genes

##ENVIRONMENT
#library(DESeq2)
#library(biomaRt)
#library(Hmisc)
library(ggplot2)
library(singscore)
#library(msigdb)
#library(multcompView)
library(FSA)
library(smplot)
library(ggpubr)
library(ggsignif)
library(rstatix)
library(ggbeeswarm)
library(ggpp)
library(BSDA)
library(openxlsx)
library(pROC)

##FUNCTIONS
#FUN, theme.plain
theme.plain <- function(p, base_size = 11, base_family = "ArialMT") {
  p <- p + theme_linedraw(base_size = base_size, base_family = base_family) %+replace%
    theme(panel.background = element_blank(),
          #panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(color="black", size=0.75),
          axis.ticks = element_line(size=0.75),
          axis.text = element_text(size=base_size-2, family="ArialMT", face="plain"),
          strip.background = element_blank(),
          strip.text = element_text(size=base_size, family="ArialMT", face="plain"),
          legend.key = element_blank(),
          legend.text = element_text(size=base_size, family = "ArialMT", face="plain"),
          complete = TRUE,
          plot.title = element_text(hjust=0.5))
  return(p)
}

#Function to add extra column with formatted p adj in scientific notation
format_dunn <- function(df){
  df$P.adj.Formatted <- formatC(df$p.adj, format = "e", digits = 2)  
  return(df)
}
#Our transformation function
scaleFUN <- function(x) sprintf("%.2f", x)

#Half violin

"%||%" <- function(a, b) {
  if (!is.null(a)) a else b
}

geom_flat_violin <- function(mapping = NULL, data = NULL, stat = "ydensity",
                             position = "dodge", trim = TRUE, scale = "area",
                             show.legend = NA, inherit.aes = TRUE, ...) {
  layer(
    data = data,
    mapping = mapping,
    stat = stat,
    geom = GeomFlatViolin,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      trim = trim,
      scale = scale,
      ...
    )
  )
}

GeomFlatViolin <-
  ggproto("GeomFlatViolin", Geom,
          setup_data = function(data, params) {
            data$width <- data$width %||%
              params$width %||% (resolution(data$x, FALSE) * 0.9)
            
            # ymin, ymax, xmin, and xmax define the bounding rectangle for each group
            data %>%
              group_by(group) %>%
              mutate(ymin = min(y),
                     ymax = max(y),
                     xmin = x - width / 2,
                     xmax = x)
          },
          
          draw_group = function(data, panel_scales, coord) {
            # Find the points for the line to go all the way around
            data <- transform(data, 
                              xmaxv = x,
                              xminv = x + violinwidth * (xmin - x))
            
            # Make sure it's sorted properly to draw the outline
            newdata <- rbind(plyr::arrange(transform(data, x = xminv), y),
                             plyr::arrange(transform(data, x = xmaxv), -y))
            
            # Close the polygon: set first and last point the same
            # Needed for coord_polar and such
            newdata <- rbind(newdata, newdata[1,])
            
            ggplot2:::ggname("geom_flat_violin", GeomPolygon$draw_panel(newdata, panel_scales, coord))
          },
          
          draw_key = draw_key_polygon,
          
          default_aes = aes(weight = 1, colour = "grey20", fill = "white", size = 0.5,
                            alpha = NA, linetype = "solid"),
          
          required_aes = c("x", "y")
  )

#Plot violin, boxplot and dotplot with statistics
ggvbds <- function(df, x, y, 
                   first.stats.method = "kruskal.test", 
                   custom.stats, 
                   col = colors,
                   y.positions = c(0.08, 0.28, 0.35)){
  ggboxplot(df, x = x, y = y,
            color = "white", palette = col, width =  0.2) +
    #Comparison of means 
    stat_compare_means(label.x = 0.8, label.y = y.positions[3]+0.1, 
                       method = first.stats.method)  +
    #Ad hoc test
    stat_pvalue_manual(custom.stats, 
                       label = "P.adj.Formatted", 
                       y.position = y.positions)     + 
    geom_flat_violin(aes(fill = get(x), color = get(x)), alpha=0.5, width=0.8) +
    geom_boxplot(aes(fill = get(x)), width=0.1, color="black", alpha=0.8, 
                 position = position_nudge(x=-0.05)) +
    geom_point(aes(color = get(x)), 
               position = position_jitternudge(width = 0.05, 
                                               x = 0.1,
                                               seed = 123,
                                               direction = "as.is",
                                               nudge.from = "jittered.x"), 
               size = 1) + theme(legend.position = "none")
}

#Functions to work with multiple data frames
split.str <- function(x) unlist(strsplit(x, split = ", "))

get.genes.clusters <- function(x) {
  x <- split.str(x)
  if (length(x) > 1 | length(x) == 0) {unlist(sapply(x, get), use.names = F)
  } else {
    get(x)
  }
}


Multiple.simpleScore <- function(combinations){
  names.list <- paste0("Upregulated Set: ", combinations$Var1, "; Downregulated Set: ", combinations$Var2)
  upSet.genes <- lapply(combinations$Var1, get.genes.clusters) 
  downSet.genes <- lapply(combinations$Var2, get.genes.clusters)
  scoredf_list <- list()
  for (i in 1:nrow(combinations)) {
    if (is.null(upSet.genes[[i]]) | is.null(downSet.genes[[i]])) {
      if (is.null(upSet.genes[[i]]) & is.null(downSet.genes[[i]])) {
        scoredf_list[[i]] <- NULL
      } else {
        if (is.null(downSet.genes[[i]])) {
          scoredf_list[[i]] <- simpleScore(rankData, upSet = upSet.genes[[i]])
        } else {
          scoredf_list[[i]] <- simpleScore(rankData, upSet = downSet.genes[[i]])
        }
      }
    } else {
      scoredf_list[[i]] <- simpleScore(rankData, upSet = upSet.genes[[i]], downSet = downSet.genes[[i]])
    }
  }
  names(scoredf_list) <- names.list
  return(scoredf_list)
}

##INPUT
#read object DEseq and metadata
#DE <- read.csv("DEG.significative_stricter_pval_l2fc_cluster.csv", sep=',')

#Reading ref for genes
RNA.ref <- read.table("/Users/R_projects/Oslo/results/eQTL/references/Homo_sapiens.GRCh37.75.genes.bed", sep = "\t", header = F)
names(RNA.ref) <- c("chr", "start_pos", "end_pos", "strand", "ENSEMBL", "SYMBOL")
RNA.ref <- RNA.ref[!duplicated(RNA.ref$ENSEMBL),]

#Loading RNA matrix
RNA.DEG <- as.matrix(read.csv(file = "./output/tables/gene_expression/RNA_matrix_zeroVar.table", sep="\t", row.names = 1))

#Loading metadata
annotation.data <- read.delim(file = "./data/processed/metadata/extended_metadata.tsv", sep = "\t", row.names = 1)
annotation.data$marsh.2 <- as.factor(annotation.data$marsh.2)

#Loading merged DEG 
DEG.merged <- read.csv(file = "./output/tables/DEG/extended_comparisons_merged.csv", header = T, stringsAsFactors = F)
cluster2 <- DEG.merged[DEG.merged$Cluster == "Cluster_2",]
cluster3 <- DEG.merged[DEG.merged$Cluster == "Cluster_3",]
cluster2 <- unique(cluster2$ENSEMBL)
cluster3 <- unique(cluster3$ENSEMBL)

cluster1 <- DEG.merged[DEG.merged$Cluster == "Cluster_1",]
cluster4 <- DEG.merged[DEG.merged$Cluster == "Cluster_4",]
cluster1 <- unique(cluster1$ENSEMBL)
cluster4 <- unique(cluster4$ENSEMBL)

#scale? not necessary, it is already ranking genes, if normalizing, may give artifacts
#base_mean <-  rowMeans(RNA.DEG)
RNA.DEG <-  t(scale(t(RNA.DEG)))

# The recommended method for dealing with ties in ranking is 'min', you can
# change by specifying 'tiesMethod' parameter for rankGenes function.
rankData <- rankGenes(RNA.DEG)

# Given the ranked data and gene signature, simpleScore returns the scores and 
# dispersions for each sample

colors <- c("#2A2B2DFF", "#2DA8D8FF", "#D9514EFF")


scoredf.t <- simpleScore(rankData, upSet = c(cluster2), downSet = c(cluster3))
scoredf.t <- simpleScore(rankData, upSet = c(cluster3))

ggplot(data = scoredf.t, mapping = aes(x = annotation.data$condition, y = TotalScore)) +
  geom_point(aes(color = annotation.data$condition))

up.gene.sets <- c("", "cluster1", "cluster2", "cluster1, cluster2")
down.gene.sets <- c("", "cluster3", "cluster4", "cluster3, cluster4")
combinations <- expand.grid(up.gene.sets, down.gene.sets, stringsAsFactors = F)



scoredf <- Multiple.simpleScore(combinations)
condition <- annotation.data$condition
scoredf <- sapply(scoredf, function(x) cbind(x, condition))
scoredf$`Upregulated Set: ; Downregulated Set: ` <- NULL
kruskal <- lapply(scoredf, function(df) {
  kruskal.test(formula = TotalScore ~ condition, data = df)$p.value
  }
  )
#kruskal$`Upregulated Set: cluster1; Downregulated Set: `$p.value

#kruskal <- kruskal.test(formula = TotalScore ~ condition, data = scoredf)
#Using dunn test
dunn.Total <- lapply(scoredf, function(df) {
  dunn.Total <- dunn_test(formula = TotalScore ~ condition,
                          data = df,
                          p.adjust.method="bonferroni")
  #Adding formatted pvalue
  dunn.Total <- format_dunn(dunn.Total)
}
)


plotRankDensity(rankData[,2,drop = FALSE], upSet = c(cluster2), 
                downSet = c(cluster3), isInteractive = FALSE)

ggvbds(df = scoredf[[12]], x = "condition", y = "TotalScore", 
       custom.stats = dunn.Total[[12]],
       y.positions = c(0.3, 0.65, 0.75)) + ggtitle(names(scoredf)[12])

scoredf_formatted <- scoredf
names(scoredf_formatted) <- gsub("regulated Set","", names(scoredf_formatted))
names(scoredf_formatted) <- gsub("\\;"," -", names(scoredf_formatted))
names(scoredf_formatted) <- gsub("\\, "," & ", names(scoredf_formatted))
names(scoredf_formatted) <- gsub("\\:","", names(scoredf_formatted))
names(scoredf_formatted) <- gsub("cluster","c", names(scoredf_formatted))

write.xlsx(x = scoredf_formatted, file = "output/tables/singscores.xlsx", row.names = T)
#AUC
scoredf_AUC <- scoredf
scoredf_AUC <- lapply(scoredf_AUC, function(x) {
  x <- x[,c("TotalScore", "condition")]
  return(x)
})
names(scoredf_AUC)
testAUC <- scoredf_AUC[[6]]
str(testAUC)
testAUC$condition <- as.factor(testAUC$condition)
roc.multi <- multiclass.roc(condition~TotalScore, testAUC)

plot_multi_roc <- function(roc.object){
  plot.roc(roc.object$rocs[[1]], 
           print.auc=T, col = "#2A2B2DFF",
           legacy.axes = T)
  plot.roc(roc.object$rocs[[2]],
           add=T, col = '#D9514EFF',
           print.auc = T,
           legacy.axes = T,
           print.auc.adj = c(0,3))
  plot.roc(roc.object$rocs[[3]],add=T, col = '#2DA8D8FF',
           print.auc=T,
           legacy.axes = T,
           print.auc.adj = c(0,5))
  #legend('bottomright',
  #       legend = c('TCD-CTRL',
  #                  'UCD-CTRL',
  #                  'UCD-TCD'),
  #       col=c('#2A2B2DFF','#D9514EFF','#2DA8D8FF'),lwd=2)
}

names(scoredf_AUC)

#Reorganizing order of list
list_score_AUC <- list(
  scoredf_AUC$`Upregulated Set: ; Downregulated Set: cluster3`,
  scoredf_AUC$`Upregulated Set: ; Downregulated Set: cluster4`,
  scoredf_AUC$`Upregulated Set: ; Downregulated Set: cluster3, cluster4`,
  
  scoredf_AUC$`Upregulated Set: cluster1; Downregulated Set: `,
  scoredf_AUC$`Upregulated Set: cluster1; Downregulated Set: cluster3`,
  scoredf_AUC$`Upregulated Set: cluster1; Downregulated Set: cluster4`,
  scoredf_AUC$`Upregulated Set: cluster1; Downregulated Set: cluster3, cluster4`,
  
  scoredf_AUC$`Upregulated Set: cluster2; Downregulated Set: `,
  scoredf_AUC$`Upregulated Set: cluster2; Downregulated Set: cluster3`,
  scoredf_AUC$`Upregulated Set: cluster2; Downregulated Set: cluster4`,
  scoredf_AUC$`Upregulated Set: cluster2; Downregulated Set: cluster3, cluster4`,
  
  scoredf_AUC$`Upregulated Set: cluster1, cluster2; Downregulated Set: `,
  scoredf_AUC$`Upregulated Set: cluster1, cluster2; Downregulated Set: cluster3`,
  scoredf_AUC$`Upregulated Set: cluster1, cluster2; Downregulated Set: cluster4`,
  scoredf_AUC$`Upregulated Set: cluster1, cluster2; Downregulated Set: cluster3, cluster4`)

#plotting
pdf(file = "./output/plots/AUC_plots_all_combinations.pdf", width=8, height=8,  family = "ArialMT")
par(mfrow= c(4,4))
plot.new()
lapply(list_score_AUC, function(df){
  df$condition <- as.factor(df$condition)
  roc.multi <- multiclass.roc(condition~TotalScore, df)
  plot_multi_roc(roc.multi)
})
dev.off()





cowplot::plot_grid(plotlist = AUC.plots,
                   ncol = 4)
#Plots
p1 <- ggvbds(df = scoredf[[1]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[1]],
             y.positions = c(0.2, 0.5, 0.6)) + ggtitle(names(scoredf)[1])
p1
p2 <- ggvbds(df = scoredf[[2]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[2]],
             y.positions = c(0.2, 0.4, 0.5)) + ggtitle(names(scoredf)[2])
p2
p3 <- ggvbds(df = scoredf[[3]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[3]],
             y.positions = c(0.2, 0.4, 0.5)) + ggtitle(names(scoredf)[3])
p3
p4 <- ggvbds(df = scoredf[[4]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[4]],
             y.positions = c(0.35, 0.45, 0.55)) + ggtitle(names(scoredf)[4])
p4
p5 <- ggvbds(df = scoredf[[5]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[5]],
             y.positions = c(0.3, 0.7, 0.85)) + ggtitle(names(scoredf)[5])
p5
p6 <- ggvbds(df = scoredf[[6]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[6]],
             y.positions = c(0.2, 0.5, 0.6)) + ggtitle(names(scoredf)[6])
p6
p7 <- ggvbds(df = scoredf[[7]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[7]],
             y.positions = c(0.25, 0.6, 0.75)) + ggtitle(names(scoredf)[7])
p7
p8 <- ggvbds(df = scoredf[[8]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[8]],
             y.positions = c(0.45, 0.55, 0.65)) + ggtitle(names(scoredf)[8])
p8
p9 <- ggvbds(df = scoredf[[9]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[9]],
             y.positions = c(0.45, 0.8, 0.95)) + ggtitle(names(scoredf)[9])
p9
p10 <- ggvbds(df = scoredf[[10]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[10]],
             y.positions = c(0.35, 0.7, 0.85)) + ggtitle(names(scoredf)[10])
p10
p11 <- ggvbds(df = scoredf[[11]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[11]],
             y.positions = c(0.4, 0.7, 0.85)) + ggtitle(names(scoredf)[11])
p11
p12 <- ggvbds(df = scoredf[[12]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[12]],
             y.positions = c(0.35, 0.45, 0.55)) + ggtitle(names(scoredf)[12])
p12
p13 <- ggvbds(df = scoredf[[13]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[13]],
             y.positions = c(0.4, 0.75, 0.9)) + ggtitle(names(scoredf)[13])
p13
p14 <- ggvbds(df = scoredf[[14]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[14]],
             y.positions = c(0.3, 0.65, 0.8)) + ggtitle(names(scoredf)[14])
p14
p15 <- ggvbds(df = scoredf[[15]], x = "condition", y = "TotalScore", 
             custom.stats = dunn.Total[[15]],
             y.positions = c(0.35, 0.75, 0.9)) + ggtitle(names(scoredf)[15])
p15
list_plots <- list(NULL,p4,p8,p12,
                   p1,p5,p9,p13,
                   p2,p6,p10,p14,
                   p3,p7,p11,p15)
list_plots <- lapply(list_plots, theme.plain)
list_plots <- lapply(list_plots, function(x){
  p <- x + theme(legend.position = "none", 
            axis.text.x = element_blank(), 
            axis.title = element_blank(),
            title = element_blank())
  return(p)
})

pdf(file = "./output/plots/Gene_scoring_plots_all_combinations.pdf", width=16, height=14,  family = "ArialMT")
cowplot::plot_grid(plotlist = list_plots,
                   ncol = 4)
dev.off()


scoredf.2.3.annotated <- scoredf[[6]]
scoredf.2.3.annotated$annotation <- paste0(annotation.data$condition, "_", annotation.data$Cluster)
scoredf.2.3.annotated$Cluster <- annotation.data$Cluster
scoredf.2.3.annotated$Cluster2 <- gsub("CTRL_Group_1", "Group_1", scoredf.2.3.annotated$annotation)
scoredf.2.3.annotated$Cluster2 <- gsub("CTRL_Group_2", "Group_1", scoredf.2.3.annotated$Cluster2)
scoredf.2.3.annotated$Cluster2 <- gsub(".*D_", "", scoredf.2.3.annotated$Cluster2)

ggplot(scoredf.2.3.annotated, aes(x = TotalScore,
                                  y = TotalDispersion)) + 
  geom_point(aes(color = annotation)) +
  geom_mark_ellipse(aes(fill = Cluster2), tol = 0.001, expand = unit(0.01, "mm")) + 
  scale_color_manual(values = c("#2A2B2DFF", "#8B8090", 
                                "#5DE7AA","#2DA8D8FF", 
                                "#BC519B", "#9260B5", "#D9514EFF"))

ggplot(scoredf.2.3.annotated, aes(x = TotalScore,
                                  y = TotalDispersion)) + 
  geom_point(aes(color = annotation)) +
  stat_ellipse(aes(fill = Cluster2), type = "t", linetype = 2) + 
  scale_color_manual(values = c("#2A2B2DFF", "#8B8090", 
                                "#5DE7AA","#2DA8D8FF", 
                                "#BC519B", "#9260B5", "#D9514EFF"))

p.2.3 <- plotDispersion(scoredf.2.3.annotated, annot = scoredf.2.3.annotated$annotation, isInteractive = FALSE) + 
  scale_color_manual(values = c("#2A2B2DFF", "#8B8090", 
                                "#5DE7AA","#2DA8D8FF", 
                                "#BC519B", "#9260B5", "#D9514EFF"))
p.2.3
p.2.3v2 <- plotDispersion(scoredf[[6]], annot = annotation.data$condition, isInteractive = FALSE) + 
  scale_color_manual(values = colors)
p.2.3v2
scoredf <- simpleScore(rankData, upSet = c(cluster1), downSet = c(cluster3))
scoredf

p.1.3 <- plotDispersion(scoredf, annot = annotation.data$condition, isInteractive = FALSE) + scale_color_manual(values = colors)

scoredf <- simpleScore(rankData, upSet = c(cluster1), downSet = c(cluster4))
scoredf

p.1.4 <- plotDispersion(scoredf, annot = annotation.data$condition, isInteractive = FALSE) + scale_color_manual(values = colors)

scoredf <- simpleScore(rankData, upSet = c(cluster2), downSet = c(cluster4))
scoredf

p.2.4 <- plotDispersion(scoredf, annot = annotation.data$condition, isInteractive = FALSE) + scale_color_manual(values = colors)

scoredf <- simpleScore(rankData, upSet = c(cluster1, cluster2), downSet = c(cluster3, cluster4))
scoredf

p.1.2.3.4 <- plotDispersion(scoredf, annot = annotation.data$condition, isInteractive = FALSE) + scale_color_manual(values = colors)

scoredf <- simpleScore(rankData, upSet = c(cluster1, cluster2), downSet = c(cluster3))
scoredf

p.1.2.3 <- plotDispersion(scoredf, annot = annotation.data$condition, isInteractive = FALSE) + scale_color_manual(values = colors)

scoredf <- simpleScore(rankData, upSet = c(cluster1, cluster2), downSet = c(cluster4))
scoredf

p.1.2.4 <- plotDispersion(scoredf, annot = annotation.data$condition, isInteractive = FALSE) + scale_color_manual(values = colors)

scoredf <- simpleScore(rankData, upSet = c(cluster1), downSet = c(cluster3, cluster4))
scoredf

p.1.3.4 <- plotDispersion(scoredf, annot = annotation.data$condition, isInteractive = FALSE) + scale_color_manual(values = colors)

scoredf <- simpleScore(rankData, upSet = c(cluster2), downSet = c(cluster3, cluster4))
scoredf

p.2.3.4 <- plotDispersion(scoredf, annot = annotation.data$condition, isInteractive = FALSE) + scale_color_manual(values = colors)
library(ggforce)
#testing references
pdf(file = "./output/plots/Gene_scoring_plots.pdf", width=9, height=3,  family = "ArialMT")
theme.plain(p.2.3) + scale_x_continuous(n.breaks = 4, labels = scaleFUN) + ggtitle("Up: Cluster 2; Down: Cluster 3")
theme.plain(p.1.4) + scale_x_continuous(n.breaks = 4, labels = scaleFUN) + ggtitle("Up: Cluster 1; Down: Cluster 4")
theme.plain(p.2.4) + scale_x_continuous(n.breaks = 4, labels = scaleFUN) + ggtitle("Up: Cluster 2; Down: Cluster 4")
theme.plain(p.1.3) + scale_x_continuous(n.breaks = 4, labels = scaleFUN) + ggtitle("Up: Cluster 1; Down: Cluster 3")

theme.plain(p.1.2.3) + scale_x_continuous(n.breaks = 4, labels = scaleFUN) + ggtitle("Up: Cluster 1 & 2; Down: Cluster 3")
theme.plain(p.1.2.4) + scale_x_continuous(n.breaks = 4, labels = scaleFUN) + ggtitle("Up: Cluster 1 & 2; Down: Cluster 4")
theme.plain(p.1.3.4) + scale_x_continuous(n.breaks = 4, labels = scaleFUN) + ggtitle("Up: Cluster 1; Down: Cluster 3 & 4")
theme.plain(p.2.3.4) + scale_x_continuous(n.breaks = 4, labels = scaleFUN) + ggtitle("Up: Cluster 2; Down: Cluster 3 & 4")

theme.plain(p.1.2.3.4) + scale_x_continuous(n.breaks = 4, labels = scaleFUN) + ggtitle("Up: Cluster 1 & 2; Down: Cluster 3 & 4")
dev.off()


plots2 <- cowplot::plot_grid(list_plots[[10]], list_plots[[9]], list_plots[[2]],
                   nrow = 1)

pdf(file = "./output/plots/Gene_scoring_plots_C2vsC3.pdf", width=10, height=7,  family = "ArialMT")
cowplot::plot_grid(theme.plain(p.2.3) + 
                     scale_x_continuous(n.breaks = 4, labels = scaleFUN) + ggtitle("Up: Cluster 2; Down: Cluster 3") + 
                     theme(legend.position = "none", axis.title.y = element_blank()), plots2, nrow = 2, rel_heights = c(1.18,1), rel_widths = c(1,1), axis = c("t"), align = c("v"))
dev.off()

pdf(file = "./output/plots/Gene_scoring_plots_C2vsC3v3.pdf", width=10, height=10,  family = "ArialMT")
cowplot::plot_grid(plots2 + ggtitle("Up: Cluster 2; Down: Cluster 3"), 
                   theme.plain(p.2.3v2) + 
                     theme(legend.position = "none",axis.title.y = element_blank()),
                   theme.plain(p.2.3)   + 
                     theme(legend.position = "none",axis.title.y = element_blank()), 
                   nrow = 3, rel_heights = c(1,1.2,1.2), rel_widths = c(1,1), axis = c("t"), align = c("v"))
dev.off()



#USING reference

RNA.DEG <- read.csv(file = "./data/raw/reference/GSE134900_normalized_expr.valerie_celiac.human.csv", sep=",")
RNA.DEG <- RNA.DEG[!duplicated(RNA.DEG$X),]

#RNA.ref[RNA.ref$SYMBOL %in% RNA.DEG$X, ]$ENSEMBL 
RNA.DEG$ENSEMBL <-  RNA.ref[match(RNA.DEG$X, RNA.ref$SYMBOL), ]$ENSEMBL
RNA.DEG <- RNA.DEG[!is.na(RNA.DEG$ENSEMBL),]
rownames(RNA.DEG) <- RNA.DEG$ENSEMBL
RNA.DEG$X <- NULL
RNA.DEG$ENSEMBL <- NULL
names(RNA.DEG) <- gsub("\\.", "-", names(RNA.DEG))

#Loading metadata
annotation.data <- t(read.table(file = "./data/raw/reference/GSE134900_series_matrix_mod.txt", sep = "\t", header = F))
annotation.data <- as.data.frame(annotation.data)
rownames(annotation.data) <- annotation.data$V1
names(annotation.data) <- paste(annotation.data[1,1:4])
annotation.data$Sample <- NULL
annotation.data <- annotation.data[2:nrow(annotation.data),]

annotation.data$Diagnosis <- gsub("diagnosis: ", "" , annotation.data$Diagnosis)
annotation.data$Age <- gsub("age: ", "" , annotation.data$Age)
annotation.data$Sex <- gsub("Sex: ", "" , annotation.data$Sex)


#RNA.DEG <- as.matrix(RNA.DEG)
#RNA.DEG <- as.data.frame(RNA.DEG)
RNA.DEG <- RNA.DEG[,rownames(annotation.data)]


# The recommended method for dealing with ties in ranking is 'min', you can
# change by specifying 'tiesMethod' parameter for rankGenes function.
rankData <- rankGenes(RNA.DEG)

# Given the ranked data and gene signature, simpleScore returns the scores and 
# dispersions for each sample




scoredf <- Multiple.simpleScore(combinations)
condition <- annotation.data$Diagnosis
condition <- gsub("CONTROL", "CTRL", condition)
condition <- gsub("ACTIVE CELIAC", "UCD", condition)
condition <- as.factor(condition)

scoredf <- sapply(scoredf, function(x) cbind(x, condition))
scoredf$`Upregulated Set: ; Downregulated Set: ` <- NULL
kruskal <- lapply(scoredf, function(df) {
  kruskal.test(formula = TotalScore ~ condition, data = df)$p.value
}
)
kruskal$`Upregulated Set: cluster1; Downregulated Set: `$p.value

#kruskal <- kruskal.test(formula = TotalScore ~ condition, data = scoredf)
#Using t test!!!! not dunn
dunn.Total <- lapply(scoredf, function(df) {
  dunn.Total <- dunn_test(formula = TotalScore ~ condition,
                          data = df,
                          p.adjust.method="bonferroni")
  #Adding formatted pvalue
  dunn.Total$p.adj <- p.adjust(dunn.Total$p, method = "bonferroni", n = 15)
  dunn.Total$P.adj.Formatted <- formatC(dunn.Total$p.adj, format = "e", digits = 2) 
  return(dunn.Total)
  #dunn.Total <- format_dunn(dunn.Total)
}
)

#AUC 
scoredf_AUC <- scoredf
scoredf_AUC <- lapply(scoredf_AUC, function(x) {
  x <- x[,c("TotalScore", "condition")]
  return(x)
})
names(scoredf_AUC)
testAUC <- scoredf_AUC[[6]]
str(testAUC)
testAUC$condition <- as.factor(testAUC$condition)
roc.multi <- multiclass.roc(condition~TotalScore, testAUC)

plot_multi_roc <- function(roc.object){
  plot.roc(roc.object$rocs[[1]], 
           print.auc=T, col = "#D9514EFF",
           legacy.axes = T)
  #legend('bottomright',
  #       legend = c('TCD-CTRL',
  #                  'UCD-CTRL',
  #                  'UCD-TCD'),
  #       col=c('#2A2B2DFF','#D9514EFF','#2DA8D8FF'),lwd=2)
}
par(mfrow= c(4,4))
plot.new()
lapply(scoredf_AUC, function(df){
  df$condition <- as.factor(df$condition)
  roc.multi <- multiclass.roc(condition~TotalScore, df)
  plot_multi_roc(roc.multi)
})

par(mfrow= c(4,4))

list_score_AUC <- list(
scoredf_AUC$`Upregulated Set: ; Downregulated Set: cluster3`,
scoredf_AUC$`Upregulated Set: ; Downregulated Set: cluster4`,
scoredf_AUC$`Upregulated Set: ; Downregulated Set: cluster3, cluster4`,

scoredf_AUC$`Upregulated Set: cluster1; Downregulated Set: `,
scoredf_AUC$`Upregulated Set: cluster1; Downregulated Set: cluster3`,
scoredf_AUC$`Upregulated Set: cluster1; Downregulated Set: cluster4`,
scoredf_AUC$`Upregulated Set: cluster1; Downregulated Set: cluster3, cluster4`,

scoredf_AUC$`Upregulated Set: cluster2; Downregulated Set: `,
scoredf_AUC$`Upregulated Set: cluster2; Downregulated Set: cluster3`,
scoredf_AUC$`Upregulated Set: cluster2; Downregulated Set: cluster4`,
scoredf_AUC$`Upregulated Set: cluster2; Downregulated Set: cluster3, cluster4`,

scoredf_AUC$`Upregulated Set: cluster1, cluster2; Downregulated Set: `,
scoredf_AUC$`Upregulated Set: cluster1, cluster2; Downregulated Set: cluster3`,
scoredf_AUC$`Upregulated Set: cluster1, cluster2; Downregulated Set: cluster4`,
scoredf_AUC$`Upregulated Set: cluster1, cluster2; Downregulated Set: cluster3, cluster4`)

#plotting
pdf(file = "./output/plots/AUC_plots_all_combinations_REF.pdf", width=8, height=8,  family = "ArialMT")
par(mfrow= c(4,4))
plot.new()
lapply(list_score_AUC, function(df){
  df$condition <- as.factor(df$condition)
  roc.multi <- multiclass.roc(condition~TotalScore, df)
  plot_multi_roc(roc.multi)
})
dev.off()

plotRankDensity(rankData[,2,drop = FALSE], upSet = c(cluster2), 
                downSet = c(cluster3), isInteractive = FALSE)

ggvbds(df = scoredf[[4]], x = "condition", y = "TotalScore", 
       custom.stats = dunn.Total[[4]],
       y.positions = c(0)) + ggtitle(names(scoredf)[4])

p1 <- ggvbds(df = scoredf[[1]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
             custom.stats = dunn.Total[[1]],
             y.positions = c(0.1)) + ggtitle(names(scoredf)[1])
p1
p2 <- ggvbds(df = scoredf[[2]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
             custom.stats = dunn.Total[[2]],
             y.positions = c(0.1)) + ggtitle(names(scoredf)[2])
p2
p3 <- ggvbds(df = scoredf[[3]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
             custom.stats = dunn.Total[[3]],
             y.positions = c(0.1)) + ggtitle(names(scoredf)[3])
p3
p4 <- ggvbds(df = scoredf[[4]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
             custom.stats = dunn.Total[[4]],
             y.positions = c(0)) + ggtitle(names(scoredf)[4])
p4
p5 <- ggvbds(df = scoredf[[5]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
             custom.stats = dunn.Total[[5]],
             y.positions = c(0.4)) + ggtitle(names(scoredf)[5])
p5
p6 <- ggvbds(df = scoredf[[6]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
             custom.stats = dunn.Total[[6]],
             y.positions = c(0.3)) + ggtitle(names(scoredf)[6])
p6
p7 <- ggvbds(df = scoredf[[7]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
             custom.stats = dunn.Total[[7]],
             y.positions = c(0.4)) + ggtitle(names(scoredf)[7])
p7
p8 <- ggvbds(df = scoredf[[8]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
             custom.stats = dunn.Total[[8]],
             y.positions = c(0.2)) + ggtitle(names(scoredf)[8])
p8
p9 <- ggvbds(df = scoredf[[9]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
             custom.stats = dunn.Total[[9]],
             y.positions = c(0.4)) + ggtitle(names(scoredf)[9])
p9
p10 <- ggvbds(df = scoredf[[10]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
              custom.stats = dunn.Total[[10]],
              y.positions = c(0.3)) + ggtitle(names(scoredf)[10])
p10
p11 <- ggvbds(df = scoredf[[11]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
              custom.stats = dunn.Total[[11]],
              y.positions = c(0.4)) + ggtitle(names(scoredf)[11])
p11
p12 <- ggvbds(df = scoredf[[12]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
              custom.stats = dunn.Total[[12]],
              y.positions = c(0.1)) + ggtitle(names(scoredf)[12])
p12
p13 <- ggvbds(df = scoredf[[13]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
              custom.stats = dunn.Total[[13]],
              y.positions = c(0.4)) + ggtitle(names(scoredf)[13])
p13
p14 <- ggvbds(df = scoredf[[14]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
              custom.stats = dunn.Total[[14]],
              y.positions = c(0.3)) + ggtitle(names(scoredf)[14])
p14
p15 <- ggvbds(df = scoredf[[15]], x = "condition", y = "TotalScore", col = colors[c(1,3)],
              custom.stats = dunn.Total[[15]],
              y.positions = c(0.4)) + ggtitle(names(scoredf)[15])
p15

list_plots <- list(NULL,p4,p8,p12,
                   p1,p5,p9,p13,
                   p2,p6,p10,p14,
                   p3,p7,p11,p15)
list_plots <- lapply(list_plots, theme.plain)
list_plots <- lapply(list_plots, function(x){
  p <- x + theme(legend.position = "none", 
                 axis.text.x = element_blank(), 
                 axis.title = element_blank(),
                 title = element_blank())
  return(p)
})

pdf(file = "./output/plots/Gene_scoring_plots_all_combinations_REF.pdf", width=16, height=14,  family = "ArialMT")
cowplot::plot_grid(plotlist = list_plots,
                   ncol = 4)
dev.off()


scoredf <- simpleScore(rankData, upSet = c(cluster2), downSet = c(cluster3))
scoredf

p.ref <- plotDispersion(scoredf, annot = condition, isInteractive = FALSE) + scale_color_manual(values = colors[c(3,1)])

pdf(file = "./output/plots/Gene_scoring_plots_ref.pdf", width=9, height=3,  family = "ArialMT")
theme.plain(p.ref) + scale_x_continuous(n.breaks = 4, labels = scaleFUN) + ggtitle("Up: Cluster 1 & 2; Down: Cluster 3 & 4")
dev.off()

scoredf <- lapply(scoredf, function(x){
  x$prediction <- "UCD"
  x[x$TotalScore < 0,]$prediction <- "CTRL"
  #x[x$TotalScore >= 0,]$prediction <- "UCD"
  #x[x$prediction != "CTRL",]$prediction <- "UCD"
  return(x)
  }
 )
lapply(scoredf, function(x){
  table(x$condition, x$prediction)
})
