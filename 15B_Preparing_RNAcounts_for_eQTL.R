#Script generated by: Aaron D. Ramirez-Sanchez 
#Goal: To do Differential Expression Analysis and create DESEQ object with model using age, batch; sex as interaction and get DEGs from dds object 

##ENVIRONMENT
library(DESeq2)
library(Matrix)
library(dplyr)   # Load the 'dplyr' package for data manipulation
library(stats)   # Load the 'stats' package for statistical functions
library(magrittr)  # Load the 'magrittr' package for piping operations
library(viridis)
library(ComplexHeatmap)
library(circlize)
library(ggplot2)
library(GGally)
library(Hmisc)
library(corrplot)
library(factoextra)

##FUNCTIONS
theme.plain <- function(p, base_size = 11, base_family = "ArialMT") {
  p <- p + theme_linedraw(base_size = base_size, base_family = base_family) %+replace%
    theme(panel.background = element_blank(),
          #panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(color="black", size=0.75),
          axis.ticks = element_line(size=0.75),
          axis.text = element_text(size=base_size, family="ArialMT", face="plain"),
          strip.background = element_blank(),
          strip.text = element_text(size=base_size, family="ArialMT", face="plain"),
          legend.key = element_blank(),
          legend.text = element_text(size=base_size, family = "ArialMT", face="plain"),
          complete = TRUE,
          plot.title = element_text(hjust=0.5))
  return(p)
}
correcting <- function(y, covs) {
  
  # Fit the linear model for each gene y to the the covariates  
  model   <- lm(y ~ ., data=covs, na.action=na.exclude, )
  
  # Extract the coefficients
  coef    <- model$coefficients
  
  # Calculate the value of x, after removing the variation that can be explained by the covariates 
  # e.g.  y = intercept + b1 * cov1 + b2 * cov2 + b3 * cov3 + residual error
  # We are interested in removing the part explained by only the covs which is:
  # [ b1 * cov1 + b2 * cov2 + b3 * cov3 ]
  # To get this part for each sample in y, we can use the predict(model) function, which will give:
  # intercept + b1 * cov1 + b2 * cov2 + b3 * cov3 
  # As we want to keep the intercept to keep the overall expression level, we remove this from the output
  # of predict(model) - coef[1]. the first item in the coefficients is the intercept.
  
  y.new <- y - (predict(model) - coef[1])
  
  return(y.new)
  
}

log.back.transforming <- function(m){
  m <- t(m)
  m <- (2^m)
  return(m)
}


##INPUT

#Reading dds object for log RNA matrix for decon eQTL
dds <- readRDS("./output/objects/dds.RDS")
#removing probes with zero variance
RNA.decon <- counts(dds)
RNA.decon <- RNA.decon[!rowVars(RNA.decon) == 0,]

#Reading metadata
coldata <- read.delim(file = "./data/processed/metadata/extended_metadata.tsv", sep = "\t", row.names = 1)

RNA.DEG <- as.matrix(read.csv(file = "./output/tables/gene_expression/RNA_matrix_zeroVar.table", sep="\t", row.names = 1))

#Reading PCs of genotypes
# read in the eigenvectors, produced in PLINK
eigenvec <- read.table('./data/processed/PCA/samples_112.eigenvec', header = FALSE, skip=0, sep = ' ')
rownames(eigenvec) <- eigenvec[,2]
eigenvec <- eigenvec[,3:ncol(eigenvec)]
colnames(eigenvec) <- paste('PC', c(1:20), sep = '')

#IMPORTANT!!! sorting using old name of sample and updating to new one
eigenvec <- eigenvec[coldata$sample,]
row.names(eigenvec) <- row.names(coldata)

##MAIN

#Filtering samples based on shared samples in FACS
RNA.bulk <- RNA.DEG[, rownames(coldata)]
#RNA.decon <- RNA.decon[, rownames(coldata)]

#Scaling and centering numeric variables to use in model
coldata <- cbind(coldata, eigenvec)
coldata$sequencing.batch <- as.factor(coldata$sequencing.batch)
coldata$sex2 <- as.factor(coldata$sex2)
coldata$condition <- as.factor(coldata$condition)
coldata$marsh.2 <- as.factor(coldata$marsh.2)
coldata$GC <- scale(coldata$GC, center = TRUE)
coldata$RIN.GS <- scale(coldata$RIN.GS, center = TRUE)
coldata$Total.reads <- scale(coldata$Total.reads, center = TRUE)
coldata$age2 <- scale(coldata$age2, center = TRUE)
coldata$crypt_ratio <- scale(coldata$crypt_ratio, center = TRUE)

df <- RNA.bulk

RNA.ref <- read.table("/Users/R_projects/Oslo/results/eQTL/references/Homo_sapiens.GRCh37.75.genes.bed", sep = "\t", header = F)
names(RNA.ref) <- c("chr", "start_pos", "end_pos", "strand", "ENSEMBL", "SYMBOL")
RNA.ref <- RNA.ref[!duplicated(RNA.ref$ENSEMBL),]
Y.genes <- RNA.ref[RNA.ref$chr == "Y", ]$ENSEMBL

df <- df[!rownames(df) %in% Y.genes, ]
# Rank your expression values from smallest to largest, then subtract 0.5 from each rank, and finally divide by the number of samples.
df_ranked <- t(apply(df, 1, rank, ties.method = "min"))

# Subtract 0.5 from each rank and divide by the number of columns (number of samples)
df_ranked_transformed <- (df_ranked - 0.5) / ncol(df)

# Using the stats::qnorm function to apply the normal quantile function to the ranked and transformed data frame
df_norm <- as.data.frame(t(apply(df_ranked_transformed, 1, qnorm)))

#PLOTTING DEG, sanity check
#Loading merged DEG 
DEG.merged <- read.csv(file = "./output/tables/DEG/comparisons_merged.csv", header = T, stringsAsFactors = F)

#Loading cell proportions
#cell.proportions <- read.table('./output/tables/FACS/cell_proportions_scaled.2groups.txt')

#Filters used for the DEG
L2FC.filter <- 1.0
p.adj.filter <- 0.01

#Colors
col_marsh <- viridis(4)

##MAIN
#Filtering data
DEG.merged <- DEG.merged[(abs(DEG.merged$log2FoldChange) > L2FC.filter & !is.na(DEG.merged$log2FoldChange)) & 
                           (DEG.merged$padj < p.adj.filter & !is.na(DEG.merged$padj)), ]
DEG.merged <- DEG.merged[!DEG.merged$ENSEMBL %in% Y.genes, ]

DEG.list <- unique(DEG.merged$ENSEMBL)
#heatmap(as.matrix(df_norm)[DEG.list, ])

names_marsh <- sort(unique(coldata[,"marsh.2"]))
names(col_marsh) <- names_marsh

column.ha <- HeatmapAnnotation(df = coldata[, c("condition", "marsh.2")],
                               col = list(condition = c("UCD" = "#D9514EFF", "CTRL" = "#2A2B2DFF", "TCD" = "#2DA8D8FF"),
                                          marsh.2 = col_marsh))

df_DEG <- df_norm[DEG.list,]

base_mean <-  rowMeans(df)
mat_scaled <-  t(scale(t(df)))

m <- Heatmap(as.matrix(mat_scaled[DEG.list,]), 
             #top_annotation = column.ha,
             name = "Rank-score", 
             km = 6, 
             column_km = 4,
             col = colorRamp2(c(-2, 0, 2), c("#2166ac", "white", "#b2182b")), 
             show_row_names = FALSE, 
             show_column_names = TRUE,
             use_raster = F,
             column_names_gp = gpar(fontsize = 6))
m

# Compute k-means with k = 4
set.seed(123)
km.res <- kmeans(df_norm, 4, nstart = 25)
print(km.res)



k.gap.genes <- fviz_nbclust(mat_scaled[DEG.list,], kmeans, 
             method = "gap_stat", 
             nboot = 100)



k.silhouette.genes <- fviz_nbclust(mat_scaled[DEG.list,], kmeans, 
                            method = "silhouette", 
                            nboot = 100)
k.wss.genes <- fviz_nbclust(mat_scaled[DEG.list,], kmeans, 
                            method = "wss", 
                            nboot = 100)
pdf(file = "./output/plots/Optimal_k_clusters_genes_gap.pdf", height = 6, width = 6)
theme.plain(k.gap.genes)
theme.plain(k.silhouette.genes)
theme.plain(k.wss.genes)
dev.off()

p.gap.genes <- fviz_nbclust(mat_scaled[DEG.list,], cluster::pam, 
                            method = "gap_stat", 
                            nboot = 100)
p.silhouette.genes <- fviz_nbclust(mat_scaled[DEG.list,], cluster::pam, 
                                   method = "silhouette", 
                                   nboot = 100)
p.wss.genes <- fviz_nbclust(mat_scaled[DEG.list,], cluster::pam, 
                            method = "wss", 
                            nboot = 100)


k.gap.samples <- fviz_nbclust(t(mat_scaled[DEG.list,]), kmeans, 
                              method = "gap_stat", 
                              nboot = 100)
k.silhouette.samples <- fviz_nbclust(t(mat_scaled[DEG.list,]), kmeans, 
                              method = "silhouette", 
                              nboot = 100)
k.wss.samples <- fviz_nbclust(t(mat_scaled[DEG.list,]), kmeans, 
                              method = "wss", 
                              nboot = 100)
pdf(file = "./output/plots/Optimal_k_clusters_samples_gap.pdf", height = 6, width = 6)
theme.plain(k.gap.samples)
theme.plain(k.silhouette.samples)
theme.plain(k.wss.samples)
dev.off()

p.gap.samples <- fviz_nbclust(t(mat_scaled[DEG.list,]), cluster::pam, 
                              method = "gap_stat", 
                              nboot = 100)
p.silhouette.samples <- fviz_nbclust(t(mat_scaled[DEG.list,]), cluster::pam, 
                                     method = "silhouette", 
                                     nboot = 100)
p.wss.samples <- fviz_nbclust(t(mat_scaled[DEG.list,]), cluster::pam, 
                              method = "wss", 
                              nboot = 100)


#adding metadata for APOA4 and KI67
extra.metadata <- read.csv(file = "./data/processed/metadata/metaData_cryptRatios_131022.txt", sep = "\t", header = T, stringsAsFactors = F)
extra.metadata$sample <- gsub("_", "", extra.metadata$sample)
rownames(extra.metadata) <- extra.metadata$sample
extra.metadata <- extra.metadata[coldata$sample, ]
rownames(extra.metadata) <- rownames(coldata)

#creating matrix for plots
mx = as.matrix(extra.metadata[,15:16])
mx = t(apply(mx, 1, function(x) x/sum(x)))
#creating colors for crypts ratio
col_fun <-  colorRamp2(c(1, 1.5, 2), c("#A1E1FF", "#52B3EB", "#005A99"))
colors <- col_fun(extra.metadata[,17])

column.ha.2 = HeatmapAnnotation(df = coldata[, c("condition", "marsh.2")],
                                Crypt_Ration = anno_barplot(coldata$crypt_ratio, 
                                                          height = unit(2, "cm"), 
                                                          gp = gpar(fill = col_fun(coldata$crypt_ratio)),
                                                          border = F),
                                col = list(condition = c("UCD" = "#D9514EFF", 
                                                         "CTRL" = "#2A2B2DFF", 
                                                         "TCD" = "#2DA8D8FF"),
                                           marsh.2 = col_marsh),
                                annotation_legend_param = list(
                                  condition = list(
                                    title = "Condition"
                                  ),
                                  marsh.2 = list(
                                    title = "Marsh"
                                  )
                                )
)

#Plotting custom heatmap with extra features
m2 <- Heatmap(as.matrix(mat_scaled[DEG.list,]), 
              top_annotation = column.ha.2,
              name = "Z-score", 
              km = 4, 
              column_km = 3,
              #split = clu_df_reordered,
              cluster_row_slices = FALSE,
              #column_split = col_df_reordered,
              col = colorRamp2(c(-2, 0, 2), c("#2166ac", "white", "#b2182b")), 
              show_row_names = FALSE, 
              show_column_names = TRUE,
              use_raster = F,
              column_names_gp = gpar(fontsize = 6))
set.seed(1234)
ht_list2 = m2
ht_list2 = draw(ht_list2)



# The resulting data frame 'df_transformed' contains the transformed values

PCA.DESeqTransform <-  function(object, ntop=1000, returnData=FALSE)
{
  # calculate the variance for each gene
  rv <- rowVars(object)
  
  # select the ntop genes by variance
  select <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
  
  # perform a PCA on the data in assay(x) for the selected genes
  pca <- prcomp(object[select,])
  return(pca)
}
#object <- as.matrix(df_norm)

#generating PCA data for 500 or 1000 most variables genes
RNA.PCA.500 <- PCA.DESeqTransform(as.matrix(df_norm), ntop = 500)
RNA.PCA.1000 <- PCA.DESeqTransform(as.matrix(df_norm), ntop = 1000)

#changinf format to df
RNA.PCA.1000.df <- as.data.frame(RNA.PCA.1000$rotation)
#reformatting colnames
colnames(RNA.PCA.1000.df) <- paste0(colnames(RNA.PCA.1000.df), "_RNA")
#sanity check that sample names are the same
identical(rownames(RNA.PCA.1000.df), rownames(coldata))

#adding  PCA from RNA to metada
coldata <- cbind(coldata, RNA.PCA.1000.df)

#plotting PCAs
plot((RNA.PCA.1000$sdev)^2)
plot(RNA.PCA.1000$sdev)
#Based on the plots, maybe 5 to 10 principal components to use from RNA
ggpairs(coldata, #aes(color = marsh.2), 
        columns = 60:69, aes(color = condition, alpha = 0.33), size = 0.01,
        upper = NULL, diag = NULL) + scale_color_viridis(discrete = T, direction = -1, alpha = 0.5) #column was calculated using grep("PC20", colnames(coldata)), and grep("PC1", colnames(coldata)), first element in both


plot.PCA.10 <- function(color.by, df, columns){
  p <- ggpairs(df, #aes(color = marsh.2), 
               columns = columns, aes(color = {{color.by}}, alpha = 0.33), 
               lower = list(continuous = wrap("points", size = 0.5), 
                            combo = wrap("facethist", size = 0.5), 
                            discrete = "facetbar", na = "na" ),
               upper = NULL, 
               #diag = NULL, 
               legend = c(2,1)) + scale_color_viridis(discrete = T, direction = -1, alpha = 0.5) + scale_fill_viridis(discrete = T, direction = -1, alpha = 0.5)
  return(theme.plain(p) + theme(legend.position = "bottom"))
}

plot.PCA.10.c <- function(color.by, df, columns){
  p <- ggpairs(df, #aes(color = marsh.2), 
               columns = columns, aes(color = {{color.by}}, alpha = 0.33), 
               lower = list(continuous = wrap("points", size = 0.5), 
                            combo = wrap("facethist", size = 0.5), 
                            discrete = "facetbar", na = "na" ),
               upper = NULL,
               #diag = list(continuous = "barDiag", discrete = "barDiag", na = "naDiag"),
               legend = c(2,1)) + scale_color_viridis(discrete = F, direction = -1, alpha = 0.5) + scale_fill_viridis(discrete = F, direction = -1, alpha = 0.5)
  return(theme.plain(p) + theme(legend.position = "bottom"))
}

cells <- read.delim(file = "./output/tables/FACS/cell_proportions_scaled.2groups.txt", row.names = 1)
cells2 <- read.delim(file = "./output/tables/FACS/cell_proportions_scaled.6groups.txt", row.names = 1)

coldata$rows <- rownames(coldata)
cells$rows <- rownames(cells)
coldata <- left_join(coldata, cells, by = "rows")
cells[rownames(coldata)  %in% rownames(cells), ]
plot.PCA.10.c(Immune_Cells, coldata, 80:89)

#FUN: pairedPCA.plots.pdf, function to make plot for categorical variables
pairedPCA.plots.pdf <- function(df.pca, test) {
  #Making correlation plots
  p <- ggpairs(df.pca[,c(80:89)],
               aes(color = df.pca[[test]], alpha = 0.33),
               title = test)
  return(theme.plain(p))
}
pairedPCA.plots.pdf(coldata, "sex2")
pdf(file = "./output/plots/PCA_plots_general_RNA.pdf", height = 12, width = 12)
plot.PCA.10(condition, coldata, 80:89)
plot.PCA.10(marsh.2, coldata, 80:89)
plot.PCA.10.c(crypt_ratio, coldata, 80:89)
plot.PCA.10(sequencing.batch, coldata, 80:89)
plot.PCA.10.c(age2, coldata, 80:89)
plot.PCA.10(sex2, coldata, 80:89)
plot.PCA.10.c(Total.reads, coldata, 80:89)
plot.PCA.10.c(GC, coldata, 80:89)
plot.PCA.10.c(RIN.GS, coldata, 80:89)
dev.off()


coldata.reduced <- coldata[,c("condition", "marsh.2", "crypt_ratio",   "sex2", "age2","sequencing.batch", "Total.reads", "RIN.GS", "GC", colnames(coldata[,80:89]))]


#CTRL =1, TCD = 2, UCD = 3
coldata.reduced$condition <- as.numeric(coldata.reduced$condition)
#A =1 B =1
coldata.reduced$sequencing.batch <- as.numeric(coldata.reduced$sequencing.batch)
#M = 2, F = 1
coldata.reduced$sex2 <- as.numeric(coldata.reduced$sex2)
coldata.reduced$marsh.2 <- as.numeric(coldata.reduced$marsh.2)
colnames(coldata.reduced) <- c("Condition",
                               "Marsh score",
                               "Crypt ratio (APOA4:KI67)",
                               "Sex",
                               "Age",
                               "Sequencing batch",
                               "Total reads",
                               "RNA integrity",
                               "%GC content",
                               gsub("_RNA","",colnames(coldata[,80:89])))
res <- cor(coldata.reduced)
res2 <- rcorr(as.matrix(coldata.reduced))
round(res, 2)
cor.test(coldata.reduced)
corrplot(res, type = "upper", order = "hclust", 
         tl.col = "black", tl.srt = 45)

col_fun_RB <- colorRamp2(c(-1, 0, 1), c("#2166ac", "white", "#b2182b"))
col_fun_RB(-1:1)
# Insignificant correlations are leaved blank
pdf(file = "./output/plots/Correlation_plots_general_RNA.pdf", height = 9, width = 9)
corrplot(res2$r, type="upper", order="original", 
         col = rev(COL2("RdBu", n = 200)),
         p.mat = res2$P, sig.level = 0.01, insig = "blank", 
         tl.col = "black")
dev.off()  


pdf(file = "./output/plots/PCA_plots_general_DNA.pdf", height = 12, width = 12)
plot.PCA.10(condition, coldata, 60:69)
plot.PCA.10(marsh.2, coldata, 60:69)
plot.PCA.10(crypt_ratio, coldata, 60:69)
plot.PCA.10(sequencing.batch, coldata, 60:69)
plot.PCA.10(age2, coldata, 60:69)
plot.PCA.10(sex2, coldata, 60:69)
plot.PCA.10(Total.reads, coldata, 60:69)
plot.PCA.10(GC, coldata, 60:69)
plot.PCA.10(RIN.GS, coldata, 60:69)
dev.off()

PCAplot <- ggplot(coldata, aes(x = PC4_RNA, y = PC5_RNA, color = marsh.2)) +
  geom_point()


# read in the eigenvectors, produced in PLINK
eigenval <- read.table('./data/processed/PCA/samples_112.eigenval', header = FALSE, skip=0, sep = ' ')
plot(eigenval$V1)
#Based on the plot, maybe taking 4 or 6 PCA from DNA

#Preparing covariates
covs.complete <- coldata
covs.marsh <- covs.complete[ ,c("marsh.2", "sequencing.batch", "age2", "sex2", "Total.reads", "GC", "RIN.GS")]
covs.crypt <- covs.complete[ ,c("crypt_ratio", "sequencing.batch", "age2", "sex2", "Total.reads", "GC", "RIN.GS")]
covs.condition <- covs.complete[ ,c("condition", "sequencing.batch", "age2", "sex2", "Total.reads", "GC", "RIN.GS")]
covs.mcc <- covs.complete[ ,c("marsh.2", "crypt_ratio", "condition", "sequencing.batch", "age2", "sex2", "Total.reads", "GC", "RIN.GS")]

#Preparing deconRNA
RNA.decon.log <- log2(RNA.decon+1)

#Correcting RNA matrix
corrected.marsh <- apply(RNA.decon.log, 1, correcting, covs = covs.marsh)
corrected.crypt <- apply(RNA.decon.log, 1, correcting, covs = covs.crypt)
corrected.condition <- apply(RNA.decon.log, 1, correcting, covs = covs.condition)
corrected.mcc <- apply(RNA.decon.log, 1, correcting, covs = covs.mcc)

#log back trnaformation
corrected.marsh <- log.back.transforming(corrected.marsh)
corrected.crypt <- log.back.transforming(corrected.crypt)
corrected.condition <- log.back.transforming(corrected.condition)
corrected.mcc <- log.back.transforming(corrected.mcc)

##OUTPUT

#Saving RNA matrix
write.table(corrected.marsh, 
            './output/tables/gene_expression/RNA_decon_marsh.table', 
            sep='\t',quote=F,col.names=NA)
write.table(corrected.crypt, 
            './output/tables/gene_expression/RNA_decon_crypt.table', 
            sep='\t',quote=F,col.names=NA)
write.table(corrected.condition, 
            './output/tables/gene_expression/RNA_decon_condition.table', 
            sep='\t',quote=F,col.names=NA)
write.table(corrected.mcc, 
            './output/tables/gene_expression/RNA_decon_mcc.table', 
            sep='\t',quote=F,col.names=NA)

write.table(rownames(coldata), './data/processed/metadata/shared.samplenames.new.txt',
            sep='\t',quote=F, row.names = F)
